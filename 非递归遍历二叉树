1、后序非递归遍历二叉树（用栈实现）

#include <iostream>
#include <stack>
using namespace std;

struct TreeNode {
    string val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(string x) : val(x), left(nullptr), right(nullptr) {}
};

void postorderTraversal(TreeNode* root) {
    if (root == nullptr) return;  //根节点不存在（空树）的处理：直接返回函数

    stack<TreeNode*> stack;
    TreeNode* prev = nullptr; // 用于记录上一个访问的节点
    TreeNode* current = root;

    while (current != nullptr || !stack.empty()) {
        // 先遍历左子树到底部
        while (current != nullptr) {
            stack.push(current);
            current = current->left;
        }

        // 定位到当前子树的右节点或者根节点
        current = stack.top();
        if (current->right == nullptr || current->right == prev) {
            // 如果右子树为空，或者右子树已经访问过，则访问根节点
            stack.pop();
            cout << current->val << " "; // 输出当前节点的值
            prev = current; // 更新prev为当前节点
            current = nullptr; // 移动到下一个节点
        }
        else {
            // 如果右子树不为空，将当前节点的右子树加入栈中，重新从右子树的左子树开始遍历（那个根节点没有左子树只有右子树的情况）
            current = current->right;
        }
    }
}

// 示例
int main() {
    TreeNode* root = new TreeNode("A");
    root->left = new TreeNode("B");
    root->right = new TreeNode("C");
    root->left->left = new TreeNode("D");
    root->left->right = new TreeNode("E");
    root->right->left = new TreeNode("F");
    root->right->right = new TreeNode("G");

    postorderTraversal(root);

    return 0;
}
