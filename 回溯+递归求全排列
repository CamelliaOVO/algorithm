给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：

输入：nums = [1]
输出：[[1]]




回溯+递归求全排列问题（不含重复数字的情况）


class Solution {
public: 
    void backcheck(vector<vector<int>>& res,vector<int>& num,int first,int len){
        if(first == len){           //first为要交换的数，属于后者，与被固定的数交换，如果换到最后一个数，则把
            res.push_back(num);    //之前每一次换存过的数组并入到res二维数组中，二维数组第一层代表每固定一个数
            return;                  //他的所有可能排列，然后换到下一个固定的数， 
        }

        for(int i =first;i<len;i++){     //i即为固定的数
            swap(num[i],num[first]);     //先把第i个和first交换，first一开始为0，再依次增加first
            backcheck(res,num,first+1,len);   //递归调用，使first加一，执行完len-1个循环，才把第一个数固定的情况整完
            swap(num[i],num[first]);  //回溯，每次换完一次都回溯到一开始的状态
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>>res;
        backcheck(res,nums,0,(int)nums.size());
        return res;

    }

};
